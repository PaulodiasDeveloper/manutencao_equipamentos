import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import openpyxl
from io import BytesIO
from sklearn.linear_model import LinearRegression

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="KPIs de Manuten√ß√£o - An√°lise Completa",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# T√≠tulo do aplicativo
st.title("üìä An√°lise de KPIs de Manuten√ß√£o")

# Fun√ß√£o para carregar dados via upload
def load_data():
    uploaded_file = st.file_uploader("üì§ Fa√ßa upload da sua base de dados Excel", type=["xlsx", "xls"])
    
    if uploaded_file is not None:
        try:
            # Ler o arquivo Excel
            df = pd.read_excel(uploaded_file)
            
            # Verificar colunas obrigat√≥rias
            colunas_obrigatorias = ['Data In√≠cio', 'Status']
            colunas_faltantes = [col for col in colunas_obrigatorias if col not in df.columns]
            
            if colunas_faltantes:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(colunas_faltantes)}")
                st.info("‚ÑπÔ∏è As colunas necess√°rias s√£o: 'Data In√≠cio' e 'Status'")
                return pd.DataFrame()
            
            # Converter colunas de data
            df['Data In√≠cio'] = pd.to_datetime(df['Data In√≠cio'], errors='coerce')
            
            if 'Data Fim' in df.columns:
                df['Data Fim'] = pd.to_datetime(df['Data Fim'], errors='coerce')
            
            # Calcular tempo de parada se n√£o existir
            if 'Tempo de Parada (h)' not in df.columns:
                if 'Data Fim' in df.columns:
                    mask = df['Data Fim'].notna() & df['Data In√≠cio'].notna()
                    df.loc[mask, 'Tempo de Parada (h)'] = (df.loc[mask, 'Data Fim'] - df.loc[mask, 'Data In√≠cio']).dt.total_seconds() / 3600
                else:
                    st.warning("‚ö†Ô∏è Coluna 'Data Fim' n√£o encontrada. N√£o foi poss√≠vel calcular tempo de parada.")
            
            # Mostrar preview dos dados com toggle
            st.success("‚úÖ Arquivo carregado com sucesso!")
            
            # # Checkbox para mostrar/ocultar preview
            # show_preview = st.checkbox("üëÅÔ∏è Mostrar preview dos dados (primeiras 5 linhas)", value=True)
            
            # if show_preview:
            #     st.write("üìã **Preview dos dados:**")
            #     st.dataframe(df.head())

            # Checkbox para mostrar/ocultar preview
            show_preview = st.checkbox("üìã Resumo da An√°lise de KPIs de Manuten√ß√£o)", value=True)
            
            if show_preview: st.write(""" 
            
            No per√≠odo de maio a agosto de 2025, a an√°lise dos dados de manuten√ß√£o revelou uma disponibilidade operacional cr√≠tica de 42,89%, com 20 paradas registradas e tempos m√©dios de reparo (MTTR) elevados (108,10h), superando o tempo entre falhas (MTBF de 1945,8h). 
            
            A maioria das paradas (95,2%) concentrou-se no hor√°rio administrativo, com pico √†s 08h. 
                                      
            A Manipuladora foi o equipamento mais problem√°tico, respons√°vel por 47,1% das paradas. As principais causas incluem substitui√ß√£o de mangueiras hidr√°ulicas e falhas mec√¢nicas. A Pir√¢mide de Bird apontou uma base significativa de atos inseguros, indicando oportunidades de preven√ß√£o." "Recomenda-se revis√£o da manuten√ß√£o preventiva, otimiza√ß√£o do estoque de pe√ßas e aten√ß√£o ao hor√°rio de pico para elevar a confiabilidade e a seguran√ßa operacional.""")


            # Mostrar informa√ß√µes do dataset
            st.markdown("## üìä **Informa√ß√µes do dataset:**")
            col_info1, col_info2, col_info3 = st.columns(3)
            with col_info1:
                st.write(f"**Total de registros:** {len(df)}")
            with col_info2:
                min_date = df['Data In√≠cio'].min()
                max_date = df['Data In√≠cio'].max()
                date_range = f"{min_date.strftime('%d/%m/%Y') if pd.notna(min_date) else 'N/A'} a {max_date.strftime('%d/%m/%Y') if pd.notna(max_date) else 'N/A'}"
                st.write(f"**Per√≠odo:** {date_range}")
            with col_info3:
                st.write(f"**Colunas dispon√≠veis:** {len(df.columns)}")
            
            return df
            
        except Exception as e:
            st.error(f"‚ùå Erro ao carregar o arquivo: {e}")
            return pd.DataFrame()
    else:
        # Instru√ß√µes para o usu√°rio
        st.info("""
        üìù **Instru√ß√µes para upload:**
        1. Clique em "Browse files" ou arraste seu arquivo Excel
        2. O arquivo deve conter pelo menos as colunas:
           - `Data In√≠cio` (obrigat√≥rio)
           - `Status` (obrigat√≥rio)
           - `Data Fim` (opcional, mas recomendado)
        3. Formatos suportados: .xlsx, .xls
        """)
        
        # Exemplo de estrutura esperada
        st.write("üìã **Exemplo de estrutura esperada:**")
        exemplo_data = {
            'Data In√≠cio': ['2025-05-05 09:00:00', '2025-05-12 08:30:00'],
            'Data Fim': ['2025-05-05 15:00:00', '2025-05-13 09:50:00'],
            'Local': ['AGR Cabi√∫nas', 'AGR Cabi√∫nas'],
            'Equipamento': ['Empilhadeira 2.5 ton', 'Empilhadeira 4 ton'],
            'Causa': ['Freio de m√£o travado', 'Cabo de bateria com folga'],
            'Status': ['Fechado', 'Fechado']
        }
        st.dataframe(pd.DataFrame(exemplo_data))
        
        return pd.DataFrame()

# Fun√ß√£o para an√°lise de hor√°rios de pico (apenas hor√°rio administrativo)
def analise_horarios_pico(df):
    """Analisa os hor√°rios de pico de paradas apenas no hor√°rio administrativo"""
    
    # Extrair hora do dia
    df['Hora'] = df['Data In√≠cio'].dt.hour
    df['Minuto'] = df['Data In√≠cio'].dt.minute
    df['Hora_Completa'] = df['Data In√≠cio'].dt.floor('H')  # Arredonda para hora completa
    
    # Definir turnos apenas para hor√°rio administrativo
    def classificar_turno(hora):
        if 6 <= hora < 12:
            return 'Manh√£ (06:00-11:59)'
        elif 12 <= hora < 14:
            return 'Almo√ßo (12:00-13:59)'
        elif 14 <= hora < 18:
            return 'Tarde (14:00-17:59)'
        elif 18 <= hora < 22:
            return 'Final de Expediente (18:00-21:59)'
        else:
            return 'Fora do Expediente'
    
    df['Turno'] = df['Hora'].apply(classificar_turno)
    
    # Filtrar apenas hor√°rio administrativo para an√°lise
    df_admin = df[df['Turno'] != 'Fora do Expediente']
    
    return df, df_admin

# Fun√ß√£o para criar gr√°fico de Pareto
def create_pareto_chart(data, category_column, value_column, title, height=500):
    """
    Cria um gr√°fico de Pareto
    """
    # Agrupar dados
    grouped_data = data.groupby(category_column)[value_column].sum().reset_index()
    grouped_data = grouped_data.sort_values(value_column, ascending=False)
    
    # Calcular percentual acumulado
    grouped_data['Cumulative Percentage'] = (grouped_data[value_column].cumsum() / grouped_data[value_column].sum() * 100)
    
    # Criar gr√°fico de barras
    fig = go.Figure()
    
    # Adicionar barras
    fig.add_trace(go.Bar(
        x=grouped_data[category_column],
        y=grouped_data[value_column],
        name='Quantidade',
        marker_color='blue'
    ))
    
    # Adicionar linha de Pareto
    fig.add_trace(go.Scatter(
        x=grouped_data[category_column],
        y=grouped_data['Cumulative Percentage'],
        name='Percentual Acumulado',
        yaxis='y2',
        mode='lines+markers',
        marker=dict(color='red', size=8),
        line=dict(color='red', width=2)
    ))
    
    # Configurar layout
    fig.update_layout(
        title=title,
        xaxis_title=category_column,
        yaxis_title=value_column,
        yaxis2=dict(
            title='Percentual Acumulado (%)',
            overlaying='y',
            side='right',
            range=[0, 100]
        ),
        height=height,
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    
    return fig, grouped_data

# Carregar dados
df = load_data()

# Verificar se os dados foram carregados
if df.empty:
    st.warning("‚è≥ Aguardando upload do arquivo para an√°lise...")
    st.stop()

# Aplicar an√°lise de hor√°rios de pico
df, df_admin = analise_horarios_pico(df)

# Sidebar com filtros
st.sidebar.header("üîß Filtros")

# Checkbox para mostrar/ocultar filtros avan√ßados
show_advanced_filters = st.sidebar.checkbox("üéõÔ∏è Mostrar filtros avan√ßados", value=True)

if show_advanced_filters:
    # Filtro por local (se a coluna existir)
    if 'Local' in df.columns:
        locais = list(df['Local'].unique())
        locais_selecionados = st.sidebar.multiselect(
            'Selecione os Locais:',
            options=locais,
            default=locais
        )
    else:
        st.sidebar.warning("‚ö†Ô∏è Coluna 'Local' n√£o encontrada nos dados.")
        locais_selecionados = []

    # Filtro por equipamento (se a coluna existir)
    if 'Equipamento' in df.columns:
        equipamentos = list(df['Equipamento'].unique())
        equipamentos_selecionados = st.sidebar.multiselect(
            'Selecione os Equipamentos:',
            options=equipamentos,
            default=equipamentos
        )
    else:
        st.sidebar.warning("‚ö†Ô∏è Coluna 'Equipamento' n√£o encontrada nos dados.")
        equipamentos_selecionados = []

    # Filtro por status
    if 'Status' in df.columns:
        status = list(df['Status'].unique())
        status_selecionados = st.sidebar.multiselect(
            'Selecione os Status:',
            options=status,
            default=status
        )
    else:
        st.sidebar.warning("‚ö†Ô∏è Coluna 'Status' n√£o encontrada nos dados.")
        status_selecionados = []

    # Filtro por turno (apenas hor√°rio administrativo)
    turnos_admin = [t for t in df['Turno'].unique() if t != 'Fora do Expediente']
    turnos_selecionados = st.sidebar.multiselect(
        'Selecione os Turnos:',
        options=turnos_admin,
        default=turnos_admin
    )

    # Filtro por per√≠odo
    if 'Data In√≠cio' in df.columns:
        min_date = df['Data In√≠cio'].min()
        max_date = df['Data In√≠cio'].max()

        if pd.notna(min_date) and pd.notna(max_date):
            periodo = st.sidebar.date_input(
                'Selecione o Per√≠odo:',
                value=(min_date, max_date),
                min_value=min_date,
                max_value=max_date
            )
        else:
            st.sidebar.warning("‚ö†Ô∏è Datas inv√°lidas para filtro de per√≠odo.")
            periodo = []
    else:
        st.sidebar.warning("‚ö†Ô∏è Coluna 'Data In√≠cio' n√£o encontrada nos dados.")
        periodo = []
else:
    # Se filtros avan√ßados estiverem ocultos, usar todos os dados
    locais_selecionados = list(df['Local'].unique()) if 'Local' in df.columns else []
    equipamentos_selecionados = list(df['Equipamento'].unique()) if 'Equipamento' in df.columns else []
    status_selecionados = list(df['Status'].unique()) if 'Status' in df.columns else []
    turnos_selecionados = [t for t in df['Turno'].unique() if t != 'Fora do Expediente']
    periodo = []

# Aplicar filtros CORRETAMENTE
df_filtrado = df.copy()

# Aplicar filtros apenas se as colunas existirem e se houver sele√ß√£o
if 'Local' in df.columns and locais_selecionados:
    df_filtrado = df_filtrado[df_filtrado['Local'].isin(locais_selecionados)]

if 'Equipamento' in df.columns and equipamentos_selecionados:
    df_filtrado = df_filtrado[df_filtrado['Equipamento'].isin(equipamentos_selecionados)]

if 'Status' in df.columns and status_selecionados:
    df_filtrado = df_filtrado[df_filtrado['Status'].isin(status_selecionados)]

if 'Turno' in df.columns and turnos_selecionados:
    df_filtrado = df_filtrado[df_filtrado['Turno'].isin(turnos_selecionados)]

# Filtro de per√≠odo - CORRE√á√ÉO IMPORTANTE
if 'Data In√≠cio' in df.columns and len(periodo) == 2:
    try:
        data_inicio = pd.to_datetime(periodo[0])
        data_fim = pd.to_datetime(periodo[1])
        # Incluir todo o dia final (at√© 23:59:59)
        data_fim = data_fim + timedelta(hours=23, minutes=59, seconds=59)
        
        df_filtrado = df_filtrado[
            (df_filtrado['Data In√≠cio'] >= data_inicio) & 
            (df_filtrado['Data In√≠cio'] <= data_fim)
        ]
    except Exception as e:
        st.error(f"Erro ao aplicar filtro de per√≠odo: {e}")

# MOSTRAR INFORMA√á√ïES SOBRE FILTROS - para debug
st.sidebar.info(f"üìä **Registros ap√≥s filtros:** {len(df_filtrado)}/{len(df)}")

# Verificar se h√° dados ap√≥s filtragem
if len(df_filtrado) == 0:
    st.warning("‚ö†Ô∏è Nenhum registro encontrado com os filtros aplicados!")
    st.info("üí° Tente ajustar os filtros ou verificar se os dados possuem as colunas necess√°rias")

# C√°lculo dos KPIs CORRETOS
paradas_fechadas = df_filtrado[df_filtrado['Status'] == 'Fechado']
paradas_abertas = df_filtrado[df_filtrado['Status'] == 'Aberto']

# Verificar se temos dados suficientes para c√°lculos
dados_suficientes = len(paradas_fechadas) > 0 and 'Tempo de Parada (h)' in df_filtrado.columns

if dados_suficientes:
    # MTTR (CORRETO)
    mttr = paradas_fechadas['Tempo de Parada (h)'].mean()

    # MTBF e Disponibilidade (CORRIGIDOS)
    if len(paradas_fechadas) > 0:
        # Usar todo o dataset filtrado para calcular o per√≠odo total
        # Isso inclui o √∫ltimo registro, mesmo que seja aberto
        data_minima = df_filtrado['Data In√≠cio'].min()
        data_maxima = df_filtrado['Data In√≠cio'].max()
        
        # Tempo total do per√≠odo analisado (considera TODOS os registros)
        tempo_total_periodo = (data_maxima - data_minima).total_seconds() / 3600
        
        # MTBF = Tempo operacional / N√∫mero de falhas
        tempo_operacional = tempo_total_periodo - paradas_fechadas['Tempo de Parada (h)'].sum()
        mtbf = tempo_operacional / len(paradas_fechadas) if len(paradas_fechadas) > 0 else 0
        
        # Disponibilidade = Tempo operacional / Tempo total
        disponibilidade = (tempo_operacional / tempo_total_periodo) * 100 if tempo_total_periodo > 0 else 100
        
    else:
        # Caso sem paradas fechadas
        mtbf = 0
        disponibilidade = 100

    # Outros c√°lculos
    tempo_total_parada = paradas_fechadas['Tempo de Parada (h)'].sum()
    tempo_operacional_calc = tempo_operacional
    
else:
    # Valores padr√£o quando n√£o h√° dados suficientes
    mttr = 0
    mtbf = 0
    disponibilidade = 0
    tempo_total_parada = 0
    tempo_operacional_calc = 0

# Total de paradas
total_paradas = len(df_filtrado)
paradas_abertas_count = len(paradas_abertas)

# Exibir KPIs
st.markdown("### üéØ Vis√£o Geral dos Principais KPIs Manuten√ß√£o")

col1, col2, col3, col4 = st.columns(4)

with col1:
    st.metric("MTTR (Horas)", f"{mttr:.2f}", "Tempo M√©dio para Reparo")
with col2:
    st.metric("MTBF (Horas)", f"{mtbf:.2f}", "Tempo M√©dio Entre Falhas")
with col3:
    st.metric("Disponibilidade (%)", f"{disponibilidade:.2f}%", "Percentual Operacional")
with col4:
    st.metric("Total de Paradas", total_paradas, f"{paradas_abertas_count} em aberto")

if dados_suficientes:
    col5, col6, col7, col8 = st.columns(4)
    with col5:
        st.metric("Tempo Total Parada (h)", f"{tempo_total_parada:.1f}", "Horas de indisponibilidade")
    with col6:
        eficiencia_manutencao = (1 - (mttr/mtbf)) * 100 if mtbf > 0 else 0
        st.metric("Efici√™ncia Manuten√ß√£o", f"{eficiencia_manutencao:.1f}%", "MTTR/MTBF")
    with col7:
        taxa_falhas = 1/mtbf if mtbf > 0 else 0
        st.metric("Taxa de Falhas", f"{taxa_falhas:.4f}", "Falhas por hora")
    with col8:
        confiabilidade = np.exp(-tempo_operacional_calc/mtbf) * 100 if mtbf > 0 else 100
        st.metric("Confiabilidade", f"{confiabilidade:.1f}%", "Probabilidade de opera√ß√£o")
else:
    st.warning("‚ö†Ô∏è Dados insuficientes para calcular todos os KPIs. Verifique se existe a coluna 'Tempo de Parada (h)' e paradas fechadas.")

# AN√ÅLISE DE HOR√ÅRIOS DE PICO - APENAS HOR√ÅRIO ADMINISTRATIVO
st.markdown("---")
st.markdown("### üïê An√°lise de Hor√°rios de Pico - Hor√°rio Administrativo")



# Estat√≠sticas sobre hor√°rio administrativo
total_paradas_admin = len(df_admin)
percentual_admin = (total_paradas_admin / len(df)) * 100 if len(df) > 0 else 0

st.info(f"üìä **{total_paradas_admin} ocorr√™ncias ({percentual_admin:.1f}%) em hor√°rio administrativo**")

col_pico1, col_pico2 = st.columns(2)

with col_pico1:
    # Distribui√ß√£o por turno (apenas administrativo)
    paradas_por_turno = df_filtrado[df_filtrado['Turno'] != 'Fora do Expediente']['Turno'].value_counts()
    fig_turno = px.bar(
        x=paradas_por_turno.index,
        y=paradas_por_turno.values,
        title="üìä Paradas por Per√≠odo do Dia",
        labels={'x': 'Per√≠odo', 'y': 'N√∫mero de Paradas'},
        color=paradas_por_turno.values,
        color_continuous_scale='Viridis'
    )
    st.plotly_chart(fig_turno, use_container_width=True)
    
    # Equipamentos mais problem√°ticos por turno
    if 'Equipamento' in df_filtrado.columns:
        st.markdown("**üîß Top 3 Equipamentos Mais Problem√°ticos por Per√≠odo:**")
        for turno in paradas_por_turno.index:
            equip_turno = df_filtrado[df_filtrado['Turno'] == turno]['Equipamento'].value_counts().head(3)
            if len(equip_turno) > 0:
                st.write(f"**{turno}:**")
                for i, (equip, count) in enumerate(equip_turno.items(), 1):
                    st.write(f"{i}. {equip} - {count} parada(s)")

with col_pico2:
    # Distribui√ß√£o por hora do dia (apenas hor√°rio administrativo)
    df_admin_filtrado = df_filtrado[df_filtrado['Turno'] != 'Fora do Expediente']
    paradas_por_hora = df_admin_filtrado['Hora'].value_counts().sort_index()
    
    fig_hora = px.bar(
        x=paradas_por_hora.index.astype(str) + ':00',
        y=paradas_por_hora.values,
        title="‚è∞ Paradas por Hora do Dia (Expediente)",
        labels={'x': 'Hora do Dia', 'y': 'N√∫mero de Paradas'},
        color=paradas_por_hora.values,
        color_continuous_scale='Blues'
    )
    st.plotly_chart(fig_hora, use_container_width=True)
    
    # Hor√°rio de pico
    if len(paradas_por_hora) > 0:
        hora_pico = paradas_por_hora.idxmax()
        total_pico = paradas_por_hora.max()
        st.metric("üïê Hor√°rio de Pico", f"{hora_pico:02d}:00", f"{total_pico} paradas")
    
    # An√°lise de tend√™ncia por dia da semana
    df_filtrado['Dia_Semana'] = df_filtrado['Data In√≠cio'].dt.day_name()
    dias_ordem = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    dias_portugues = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo']
    
    paradas_por_dia = df_filtrado['Dia_Semana'].value_counts().reindex(dias_ordem, fill_value=0)
    paradas_por_dia.index = dias_portugues
    
    fig_dia = px.bar(
        x=paradas_por_dia.index,
        y=paradas_por_dia.values,
        title="üìÖ Paradas por Dia da Semana",
        labels={'x': 'Dia da Semana', 'y': 'N√∫mero de Paradas'},
        color=paradas_por_dia.values,
        color_continuous_scale='Blues'
    )
    st.plotly_chart(fig_dia, use_container_width=True)

# An√°lise detalhada do hor√°rio de pico
st.markdown("#### üîç An√°lise Detalhada do Hor√°rio de Pico")

if len(paradas_por_hora) > 0:
    hora_pico = paradas_por_hora.idxmax()
    paradas_pico = df_filtrado[df_filtrado['Hora'] == hora_pico]
    
    col_pico3, col_pico4, col_pico5 = st.columns(3)
    
    with col_pico3:
        # Equipamentos no hor√°rio de pico
        if 'Equipamento' in paradas_pico.columns:
            equip_pico = paradas_pico['Equipamento'].value_counts().head(5)
            st.write("**üîß Equipamentos no Pico:**")
            for equip, count in equip_pico.items():
                st.write(f"- {equip}: {count} parada(s)")
    
    with col_pico4:
        # Locais no hor√°rio de pico
        if 'Local' in paradas_pico.columns:
            local_pico = paradas_pico['Local'].value_counts().head(3)
            st.write("**üè≠ Locais no Pico:**")
            for local, count in local_pico.items():
                st.write(f"- {local}: {count} parada(s)")
    
    with col_pico5:
        # Causas no hor√°rio de pico
        if 'Causa' in paradas_pico.columns:
            causa_pico = paradas_pico['Causa'].value_counts().head(3)
            st.write("**‚ö° Causas no Pico:**")
            for causa, count in causa_pico.items():
                st.write(f"- {causa}: {count} parada(s)")

# An√°lise de padr√µes temporais
st.markdown("#### üìà Padr√µes Temporais das Paradas")

col_temp1, col_temp2 = st.columns(2)

with col_temp1:
    # Paradas por m√™s
    df_filtrado['M√™s'] = df_filtrado['Data In√≠cio'].dt.strftime('%Y-%m')
    paradas_por_mes = df_filtrado['M√™s'].value_counts().sort_index()
    
    fig_mes = px.line(
        x=paradas_por_mes.index,
        y=paradas_por_mes.values,
        title="üìÖ Tend√™ncia de Paradas por M√™s",
        labels={'x': 'M√™s', 'y': 'N√∫mero de Paradas'},
        markers=True
    )
    st.plotly_chart(fig_mes, use_container_width=True)

with col_temp2:
    # Distribui√ß√£o por tipo de dia (√∫til vs final de semana)
    def classificar_tipo_dia(dia):
        if dia in ['Saturday', 'Sunday']:
            return 'Final de Semana'
        else:
            return 'Dia √ötil'
    
    df_filtrado['Tipo_Dia'] = df_filtrado['Dia_Semana'].apply(classificar_tipo_dia)
    paradas_por_tipo_dia = df_filtrado['Tipo_Dia'].value_counts()
    
    fig_tipo_dia = px.pie(
        values=paradas_por_tipo_dia.values,
        names=paradas_por_tipo_dia.index,
        title="üìä Paradas: Dia √ötil vs Final de Semana"
    )
    st.plotly_chart(fig_tipo_dia, use_container_width=True)

# PIR√ÇMIDE DE BIRD
st.markdown("---")
st.markdown("### üèóÔ∏è Pir√¢mide de Bird - An√°lise de Seguran√ßa")

# Dados para a pir√¢mide (valores baseados na rela√ß√£o cl√°ssica 1-3-8-20-600)
piramide_data = {
    'N√≠vel': ['Acidente com Afastamento', 'Acidente sem Afastamento', 
              'Incidente com Danos', 'Quase Acidentes', 'Atos Inseguros'],
    'Quantidade': [1, 3, 8, 20, 600],
    'Cor': ['#FF6B6B', '#FF8E53', '#FFB142', '#FFDA79', '#FFF8E1'],
    'Descri√ß√£o': [
        'Les√µes graves com afastamento',
        'Les√µes leves sem afastamento',
        'Danos materiais significativos',
        'Situa√ß√µes que quase resultaram em acidentes',
        'Comportamentos ou condi√ß√µes inseguras'
    ]
}

fig_piramide = go.Figure()

fig_piramide.add_trace(go.Bar(
    y=piramide_data['N√≠vel'],
    x=piramide_data['Quantidade'],
    orientation='h',
    marker_color=piramide_data['Cor'],
    text=piramide_data['Quantidade'],
    textposition='auto',
    hovertemplate='<b>%{y}</b><br>Quantidade: %{x}<br>%{customdata}<extra></extra>',
    customdata=piramide_data['Descri√ß√£o']
))

fig_piramide.update_layout(
    title="Pir√¢mide de Bird - Rela√ß√£o de Eventos de Seguran√ßa",
    xaxis_title="Quantidade de Ocorr√™ncias (escala logar√≠tmica)",
    yaxis_title="N√≠vel de Gravidade",
    showlegend=False,
    height=500,
    xaxis_type="log"
)

st.plotly_chart(fig_piramide, use_container_width=True)

# AN√ÅLISE DE PARETO - NOVA SE√á√ÉO ADICIONADA
st.markdown("---")
st.markdown("### üìä Principais An√°lise Causas de Parada")

if len(df_filtrado) > 0:
    # Selecionar a coluna para an√°lise de Pareto
    pareto_options = []
    if 'Causa' in df_filtrado.columns:
        pareto_options.append('Causa')
    if 'Equipamento' in df_filtrado.columns:
        pareto_options.append('Equipamento')
    if 'Local' in df_filtrado.columns:
        pareto_options.append('Local')
    
    if pareto_options:
        pareto_category = st.selectbox(
            "Selecione a categoria para an√°lise de Pareto:",
            options=pareto_options,
            index=0
        )
        
        # Criar gr√°fico de Pareto
        if 'Tempo de Parada (h)' in df_filtrado.columns:
            # Usar tempo de parada como valor
            fig_pareto, pareto_data = create_pareto_chart(
                df_filtrado, 
                pareto_category, 
                'Tempo de Parada (h)', 
                f'Pareto - Tempo de Parada por {pareto_category}',
                height=600
            )
        else:
            # Usar contagem de ocorr√™ncias como valor
            fig_pareto, pareto_data = create_pareto_chart(
                df_filtrado, 
                pareto_category, 
                'Status',  # Usaremos qualquer coluna s√≥ para contar
                f'Pareto - N√∫mero de Paradas por {pareto_category}',
                height=600
            )
            # Ajustar para usar contagem em vez de soma
            pareto_count = df_filtrado[pareto_category].value_counts().reset_index()
            pareto_count.columns = [pareto_category, 'Count']
            pareto_count = pareto_count.sort_values('Count', ascending=False)
            pareto_count['Cumulative Percentage'] = (pareto_count['Count'].cumsum() / pareto_count['Count'].sum() * 100)
            
            fig_pareto.data[0].y = pareto_count['Count']
            fig_pareto.data[1].y = pareto_count['Cumulative Percentage']
        
        st.plotly_chart(fig_pareto, use_container_width=True)
        
        # Mostrar tabela com dados do Pareto
        with st.expander("üìã Ver dados detalhados do Pareto"):
            st.dataframe(pareto_data)
            
            # An√°lise 80/20
            if len(pareto_data) > 0:
                eighty_percent_index = pareto_data[pareto_data['Cumulative Percentage'] >= 80].index.min()
                if not pd.isna(eighty_percent_index):
                    top_categories = pareto_data.head(eighty_percent_index + 1)
                    st.write(f"**Princ√≠pio 80/20:** {len(top_categories)} categorias representam 80% do total")
                    for i, row in top_categories.iterrows():
                        st.write(f"- {row[pareto_category]}: {row['Cumulative Percentage']:.1f}%")
    else:
        st.warning("‚ÑπÔ∏è N√£o h√° colunas adequadas para an√°lise de Pareto (Causa, Equipamento ou Local).")
else:
    st.warning("‚ö†Ô∏è N√£o h√° dados para an√°lise de Pareto.")

# Gr√°ficos de an√°lise
st.markdown("---")
st.markdown("### üìä An√°lise Detalhada das Paradas")

# Checkbox para mostrar/ocultar gr√°ficos
show_charts = st.checkbox("üìà Mostrar gr√°ficos de an√°lise", value=True)

if show_charts:
    # Gr√°ficos condicionais baseados nas colunas dispon√≠veis
    colunas_disponiveis = df_filtrado.columns

    if 'Local' in colunas_disponiveis:
        col11, col12 = st.columns(2)
        
        with col11:
            # Paradas por Local
            paradas_por_local = df_filtrado['Local'].value_counts()
            fig_local = px.bar(
                x=paradas_por_local.index,
                y=paradas_por_local.values,
                labels={'x': 'Local', 'y': 'N√∫mero de Paradas'},
                title="Paradas por Local",
                color=paradas_por_local.values,
                color_continuous_scale='Blues'
            )
            st.plotly_chart(fig_local, use_container_width=True)

        with col12:
            if 'Equipamento' in colunas_disponiveis:
                # Paradas por Equipamento
                paradas_por_equipamento = df_filtrado['Equipamento'].value_counts()
                fig_equipamento = px.pie(
                    values=paradas_por_equipamento.values,
                    names=paradas_por_equipamento.index,
                    title="Distribui√ß√£o de Paradas por Equipamento"
                )
                st.plotly_chart(fig_equipamento, use_container_width=True)

    if 'Data In√≠cio' in colunas_disponiveis:
        col13, col14 = st.columns(2)
        
        with col13:
            # Tempo de Parada por M√™s
            df_filtrado['M√™s'] = df_filtrado['Data In√≠cio'].dt.to_period('M').astype(str)
            tempo_por_mes = df_filtrado.groupby('M√™s')['Tempo de Parada (h)'].sum().reset_index() if 'Tempo de Parada (h)' in colunas_disponiveis else df_filtrado.groupby('M√™s').size().reset_index(name='Count')
            fig_tempo_mes = px.line(
                tempo_por_mes,
                x='M√™s',
                y='Tempo de Parada (h)' if 'Tempo de Parada (h)' in colunas_disponiveis else 'Count',
                title="Tend√™ncia de Paradas por M√™s",
                markers=True
            )
            st.plotly_chart(fig_tempo_mes, use_container_width=True)

        with col14:
            if 'Causa' in colunas_disponiveis:
                # Tipo de Manuten√ß√£o
                def classificar_manutencao(causa):
                    if pd.isna(causa):
                        return "N√£o Especificada"
                    causa_lower = str(causa).lower()
                    if any(word in causa_lower for word in ['preventiv', 'lavagem', 'programada', 'manuten√ß√£o preventiva', 'preventiva']):
                        return "Preventiva"
                    else:
                        return "Corretiva"

                df_filtrado['Tipo Manuten√ß√£o'] = df_filtrado['Causa'].apply(classificar_manutencao)
                manutencao_por_tipo = df_filtrado['Tipo Manuten√ß√£o'].value_counts()
                fig_tipo = px.pie(
                    values=manutencao_por_tipo.values,
                    names=manutencao_por_tipo.index,
                    title="Distribui√ß√£o por Tipo de Manuten√ß√£o"
                )
                st.plotly_chart(fig_tipo, use_container_width=True)

    # An√°lise de causas
    if 'Causa' in colunas_disponiveis:
        st.markdown("### üîç An√°lise de Causas")
        
        causas_texto = ' '.join(df_filtrado['Causa'].dropna().astype(str))
        palavras_chave = [word for word in causas_texto.lower().split() if len(word) > 4]
        if palavras_chave:
            palavras_frequentes = pd.Series(palavras_chave).value_counts().head(10)
            
            fig_causas = px.bar(
                x=palavras_frequentes.values, 
                y=palavras_frequentes.index,
                orientation='h',
                title="Palavras-chave Mais Frequentes nas Causas",
                labels={'x': 'Frequ√™ncia', 'y': 'Palavra-chave'},
                color=palavras_frequentes.values,
                color_continuous_scale='Reds'
            )
            st.plotly_chart(fig_causas, use_container_width=True)



# An√°lise de Regress√£o Linear para Previs√£o de Produtividade

# An√°lise de Regress√£o Linear para Previs√£o de Produtividade

st.markdown("## üî¨ An√°lise de Regress√£o Linear para Previs√£o de Produtividade")

col_treino1, col_treino2 = st.columns(2)
with col_treino1:
    var_alvo = st.selectbox('Selecione a vari√°vel de produtividade/alvo:', [col for col in df_filtrado.columns if df_filtrado[col].dtype in [np.float64, np.int64]], key='reg_target')
with col_treino2:
    vars_exp = st.multiselect('Selecione vari√°veis explicativas:', [col for col in df_filtrado.columns if (df_filtrado[col].dtype in [np.float64, np.int64] and col != var_alvo)], key='reg_features')

if var_alvo and vars_exp:
    df_model = df_filtrado.dropna(subset=[var_alvo]+vars_exp)
    X = df_model[vars_exp].values
    y = df_model[var_alvo].values
    modelo = LinearRegression()
    modelo.fit(X, y)
    st.write(f"**Coeficientes:** {modelo.coef_}")
    st.write(f"**Intercepto:** {modelo.intercept_:.2f}")
    st.write(f"**R¬≤ (explica√ß√£o da regress√£o):** {modelo.score(X,y):.3f}")

    novo = st.text_input(f'Digite valores para {vars_exp} separados por v√≠rgula para prever produtividade:', key='reg_input')
    if novo:
        try:
            valores = np.array([float(val) for val in novo.split(',')]).reshape(1,-1)
            pred = modelo.predict(valores)
            st.success(f"Produtividade prevista: {pred[0]:.2f}")
        except Exception:
            st.error("Formato inv√°lido! Insira valores num√©ricos separados por v√≠rgula.")
else:
    st.info("Selecione o alvo e ao menos uma vari√°vel explicativa para rodar a regress√£o.")




# Recomenda√ß√µes finais baseadas na an√°lise de hor√°rio administrativo
st.markdown("---")
st.markdown("### üéØ Recomenda√ß√µes Estrat√©gicas - Hor√°rio Administrativo")

# Encontrar turno e hora de pico para recomenda√ß√µes espec√≠ficas
turno_pico = paradas_por_turno.index[0] if len(paradas_por_turno) > 0 else "Tarde"
hora_pico_val = paradas_por_hora.idxmax() if len(paradas_por_hora) > 0 else 14

recomendacoes = {
    "Prioridade Alta": [
        f"Refor√ßar manuten√ß√£o preventiva no per√≠odo da {turno_pico}",
        f"Aten√ß√£o especial √†s {hora_pico_val:02d}:00h (hor√°rio de pico)",
        "Implementar checklist matinal antes do in√≠cio das opera√ß√µes",
        "Treinamento espec√≠fico para operadores nos hor√°rios de maior movimento",
        "Estoque estrat√©gico de pe√ßas para falhas mais frequentes"
    ],
    "Prioridade M√©dia": [
        "Rota√ß√£o de equipamentos durante os hor√°rios de pico",
        "Sistema de alerta para manuten√ß√£o preventiva baseado em hor√°rios",
        "An√°lise mensal de indicadores por turno",
        "Programa de inspe√ß√£o visual di√°ria"
    ],
    "Prioridade Baixa": [
        "Estudo de redistribui√ß√£o de carga hor√°ria",
        "Benchmark com outras unidades com perfis similares",
        "Implementa√ß√£o de sistema preditivo de manuten√ß√£o"
    ]
}

for prioridade, itens in recomendacoes.items():
    with st.expander(f"{prioridade}"):
        for item in itens:
            st.write(f"‚Ä¢ {item}")

# Tabela com dados detalhados
st.markdown("---")
st.markdown("### üìã Dados Detalhados das Paradas")

# Mostrar estat√≠sticas dos filtros
st.info(f"**Total de registros carregados:** {len(df)}")
st.success(f"**Registros ap√≥s filtros:** {len(df_filtrado)}")

# Checkbox para mostrar/ocultar tabela completa
show_full_table = st.checkbox("üìä Mostrar tabela completa de dados", value=False)

if show_full_table:
    # Mostrar todas as colunas e linhas
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', 1000)
    
    st.dataframe(df_filtrado, height=400, use_container_width=True)
    
    # Bot√£o para mostrar informa√ß√µes t√©cnicas
    if st.button("üîç Mostrar informa√ß√µes t√©cnicas da tabela"):
        st.write(f"**Forma da tabela:** {df_filtrado.shape}")
        st.write(f"**Colunas:** {list(df_filtrado.columns)}")
        st.write(f"**Intervalo de datas:** {df_filtrado['Data In√≠cio'].min()} a {df_filtrado['Data In√≠cio'].max()}")
else:
    st.write(f"**Total de registros filtrados:** {len(df_filtrado)}")
    st.write("üí° Marque a caixa acima para visualizar a tabela completa")

# Download dos dados filtrados - CORRIGIDO
@st.cache_data
def convert_df_to_csv(df):
    return df.to_csv(index=False, encoding='utf-8', sep=';')

if len(df_filtrado) > 0:
    csv = convert_df_to_csv(df_filtrado)
    
    st.download_button(
        label=f"üì• Baixar dados filtrados ({len(df_filtrado)} registros)",
        data=csv,
        file_name="paradas_manutencao_analise.csv",
        mime="text/csv",
    )
else:
    st.warning("N√£o h√° dados para download")

# Informa√ß√µes finais na sidebar
st.sidebar.markdown("---")
st.sidebar.markdown("""
**üìã Sobre os KPIs:**

**MTTR (Mean Time To Repair):**
- Tempo m√©dio para reparar uma falha
- F√≥rmula: Œ£(Tempo de reparo) / N¬∫ de reparos
- Meta: Quanto menor, melhor
- Tempo m√©dio de reparo elevado ‚Äì indica lentid√£o na resolu√ß√£o 108.10 h

**MTBF (Mean Time Between Failures):**
- Tempo m√©dio entre falhas
- F√≥rmula: Tempo operacional / N¬∫ de falhas
- Meta: Quanto maior, melhor
- Baixo tempo entre falhas ‚Äì equipamentos falham com frequ√™ncia

**Disponibilidade:**
- Percentual de tempo operacional
- F√≥rmula: (Tempo operacional / Tempo total) √ó 100
- Meta: >95%
- Muito abaixo do ideal (>95%) ‚Äì impacto direto na opera√ß√£o

**Efici√™ncia Manuten√ß√£o:**                
- Efici√™ncia da Manuten√ß√£o -33.2%
- Processo ineficaz ‚Äì poss√≠veis gargalos ou falta de recursos

**Taxa de Falhas:**
- Alta frequ√™ncia de quebras 0.0123 h

**Confiabilidade:**
- Nenhum equipamento operou sem falhas no per√≠odo 0.0%


**üèóÔ∏è Pir√¢mide de Bird:**
Rela√ß√£o 1-3-8-20-600 mostra que para cada acidente grave h√°:
- 3 acidentes leves
- 8 incidentes com danos
- 20 quase acidentes
- 600 atos inseguros

**üìä An√°lise de Pareto:**
Princ√≠pio 80/20 onde 20% das causas geram 80% dos problemas
""")

st.sidebar.markdown("---")
st.sidebar.info("üìä **Dashboard desenvolvido para an√°lise de KPIs de manuten√ß√£o**")